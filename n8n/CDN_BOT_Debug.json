{
  "name": "CDN_BOT",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "triage",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -16,
        -208
      ],
      "id": "a1524ed4-94b2-4071-84e7-29c80ab2b205",
      "name": "Webhook",
      "webhookId": "bf4f9f60-fd4e-4043-990f-ffaa282fa61b"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\"status\":\"ok\",\"message\":\"Running CDN triage\"}",
        "options": {
          "responseCode": 200
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [
        848,
        -208
      ],
      "id": "dfc9bad4-32d5-4869-a36a-78a90d878aac",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "url": "https://raw.githubusercontent.com/kganigap-291992/cdn-triage-bot/main/data/cdn_logs_60m_10k.csv",
        "options": {
          "response": {
            "response": {
              "responseFormat": "text",
              "outputPropertyName": "csvText"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        416,
        112
      ],
      "id": "eab674fb-a2dc-4356-b953-90ee35ec46d4",
      "name": "HTTP Request"
    },
    {
      "parameters": {
        "authentication": "oAuth2",
        "select": "channel",
        "channelId": {
          "__rl": true,
          "value": "C0AA7U6FK7T",
          "mode": "list",
          "cachedResultName": "triage_lab"
        },
        "text": "={{$json.summaryText}}\n",
        "otherOptions": {}
      },
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2.4,
      "position": [
        976,
        112
      ],
      "id": "0b9b338c-aa64-453c-801b-2bd4d25bedf7",
      "name": "Send a message",
      "webhookId": "1f0aab26-7545-45ea-9409-51f887e0c329",
      "credentials": {
        "slackOAuth2Api": {
          "id": "xy8gwdrvOqRONnE3",
          "name": "Slack account 3"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const body = $json.body ?? $json;\nconst rawText = String(body.text ?? \"\").trim();\n\nfunction splitTokens(s){ return s.split(/[\\s,]+/).filter(Boolean); }\n\nfunction parseWindow(v){\n  if(!v) return 60;\n  const m = String(v).match(/^(\\d+)([mhd])?$/i);\n  if(!m) return 60;\n  let n = parseInt(m[1], 10);\n  let u = (m[2] ?? \"m\").toLowerCase();\n  if(u === \"h\") n *= 60;\n  if(u === \"d\") n *= 1440;\n  return Math.min(n, 240);\n}\n\nfunction parseBool(v){\n  if(v == null) return false;\n  const s = String(v).trim().toLowerCase();\n  return [\"1\",\"true\",\"yes\",\"y\",\"on\"].includes(s);\n}\n\nlet service=\"all\", region=\"all\", pop=\"all\", windowMinutes=60;\nlet debug=false;\nconst filters=[];\n\nfor(const t of splitTokens(rawText)){\n  const parts = t.split(\"=\");\n  const key = String(parts.shift() ?? \"\").trim().toLowerCase();\n  const value = parts.join(\"=\").trim(); // allow '=' in value\n\n  if(key === \"service\") service = value || \"all\";\n  else if(key === \"region\") region = value || \"all\";\n  else if(key === \"pop\") pop = value || \"all\";\n  else if(key === \"window\") windowMinutes = parseWindow(value);\n  else if(key === \"debug\") debug = parseBool(value || \"1\");\n  else if(key === \"edge_status\"){\n    const v = value;\n    if(v && v.toLowerCase().endsWith(\"xx\")){\n      const b = parseInt(v[0], 10) * 100;\n      filters.push({ key:\"edge_status\", type:\"range\", min:b, max:b+99 });\n    }\n  }\n}\n\nreturn [{ json:{ service, region, pop, windowMinutes, filters, debug } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        416,
        -208
      ],
      "id": "08ccfd22-e5c2-4104-9fb7-84decb537b9a",
      "name": "Parser"
    },
    {
      "parameters": {
        "jsCode": "/**\n * CDN TRIAGE BOT — METRICS ENGINE (Complete n8n Code node)\n * =======================================================\n * What this node does\n * -------------------\n * 1) Pulls parsed inputs from the \"Parser\" node:\n *      - service, region, pop, windowMinutes, filters, debug\n * 2) Reads CSV text from the prior HTTP node ($json.csvText or $json.body)\n * 3) Parses CSV -> rows\n * 4) Normalizes dataset into canonical dimensions:\n *      - service  (from delivery_service)\n *      - region   (derived from url host: edge-<region>-<pop>)\n *      - pop      (derived from url host)\n * 5) Anchors time window on MAX ts in the CSV, slices to last N minutes\n * 6) Applies filters + computes:\n *      - total requests\n *      - 5xx error rate (edge_status >= 500)\n *      - p95 TTMS (ttms_ms)\n * 7) Returns Slack-ready summaryText + structured metrics (+ debug when enabled)\n *\n * IMPORTANT:\n * ----------\n * Your CSV uses timestamps like:\n *   2026-01-20T16:00:00.433647156\n * which is nanosecond precision (9 digits). JavaScript Date.parse is not\n * consistently happy with that. We normalize it to milliseconds and treat it as UTC.\n */\n\n// ------------------------------------------------------------\n// Helpers: dimensions, formatting, and safe parsing\n// ------------------------------------------------------------\nfunction matchDim(value, expected) {\n  if (!expected || expected === \"all\") return true;\n  return String(value).toLowerCase() === String(expected).toLowerCase();\n}\n\nfunction topValues(rows, key, limit = 8) {\n  const counts = new Map();\n  for (const r of rows) {\n    const v = (r?.[key] ?? \"\").toString().trim().toLowerCase();\n    if (!v) continue;\n    counts.set(v, (counts.get(v) ?? 0) + 1);\n  }\n  return [...counts.entries()]\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, limit)\n    .map(([v, c]) => `${v} (${c})`);\n}\n\nfunction prettyFilters(filters) {\n  if (!filters?.length) return \"none\";\n  return filters.map(f => {\n    if (f?.type === \"range\") return `${f.key}=${f.min}-${f.max}`;\n    return `${f?.key ?? \"filter\"}`;\n  }).join(\", \");\n}\n\nfunction normalizeIsoToMsUtc(ts) {\n  if (!ts) return null;\n  let s = String(ts).trim();\n  if (!s) return null;\n\n  const hasTZ = /Z$|[+-]\\d\\d:\\d\\d$/.test(s);\n  const m = s.match(/^(.+?)(\\.(\\d+))?(Z|[+-]\\d\\d:\\d\\d)?$/);\n  if (!m) return null;\n\n  const base = m[1];\n  const frac = m[3] ?? \"\";\n  const tz = m[4] ?? (hasTZ ? \"\" : \"Z\");\n\n  const ms = (frac + \"000\").slice(0, 3);\n  const iso = `${base}.${ms}${tz || \"Z\"}`;\n  return iso;\n}\n\nfunction toMs(ts) {\n  const iso = normalizeIsoToMsUtc(ts);\n  if (!iso) return NaN;\n  const ms = Date.parse(iso);\n  return Number.isFinite(ms) ? ms : NaN;\n}\n\nfunction percentile(arr, p) {\n  if (!arr || arr.length === 0) return null;\n  const sorted = [...arr].sort((a, b) => a - b);\n  const idx = (p / 100) * (sorted.length - 1);\n  const lo = Math.floor(idx);\n  const hi = Math.ceil(idx);\n  if (lo === hi) return sorted[lo];\n  const w = idx - lo;\n  return sorted[lo] * (1 - w) + sorted[hi] * w;\n}\n\nfunction deriveRegionPopFromUrl(u) {\n  const s = String(u || \"\");\n  const m = s.match(/:\\/\\/edge-([a-z0-9]+)-([a-z0-9]+)\\b/i);\n  if (!m) return { region: null, pop: null };\n  return { region: m[1].toLowerCase(), pop: m[2].toLowerCase() };\n}\n\nfunction parseCsv(csvText) {\n  const text = String(csvText).trim();\n  if (!text) return [];\n\n  const lines = text.split(/\\r?\\n/);\n  if (lines.length < 2) return [];\n\n  function splitCsvLine(line) {\n    const out = [];\n    let cur = \"\";\n    let inQuotes = false;\n\n    for (let i = 0; i < line.length; i++) {\n      const ch = line[i];\n\n      if (ch === '\"') {\n        if (inQuotes && line[i + 1] === '\"') {\n          cur += '\"';\n          i++;\n        } else {\n          inQuotes = !inQuotes;\n        }\n      } else if (ch === \",\" && !inQuotes) {\n        out.push(cur);\n        cur = \"\";\n      } else {\n        cur += ch;\n      }\n    }\n    out.push(cur);\n    return out.map(s => s.trim());\n  }\n\n  const headers = splitCsvLine(lines[0]).map(h => h.replace(/^\"|\"$/g, \"\").trim());\n\n  const rows = [];\n  for (let i = 1; i < lines.length; i++) {\n    const line = lines[i];\n    if (!line || !line.trim()) continue;\n\n    const cols = splitCsvLine(line);\n    const obj = {};\n\n    for (let c = 0; c < headers.length; c++) {\n      const key = headers[c];\n      let val = cols[c] ?? \"\";\n      val = val.replace(/^\"|\"$/g, \"\");\n      obj[key] = val;\n    }\n\n    // Numeric normalization\n    if (obj.edge_status !== undefined) obj.edge_status = Number(obj.edge_status);\n    if (obj.mid_status !== undefined) obj.mid_status = Number(obj.mid_status);\n    if (obj.ttms_ms !== undefined) obj.ttms_ms = Number(obj.ttms_ms);\n    if (obj.upstream_bytes !== undefined) obj.upstream_bytes = Number(obj.upstream_bytes);\n\n    // Normalize dims expected by filtering code:\n    obj.service = obj.delivery_service ?? obj.service;\n\n    const rp = deriveRegionPopFromUrl(obj.url);\n    obj.region = obj.region ?? rp.region;\n    obj.pop = obj.pop ?? rp.pop;\n\n    rows.push(obj);\n  }\n\n  return rows;\n}\n\nfunction passesFilter(row, f) {\n  if (!f || !f.key) return true;\n\n  const v = row[f.key];\n\n  if (f.type === \"range\") {\n    const n = Number(v);\n    if (!Number.isFinite(n)) return false;\n    const minOk = f.min == null ? true : n >= Number(f.min);\n    const maxOk = f.max == null ? true : n <= Number(f.max);\n    return minOk && maxOk;\n  }\n\n  return true;\n}\n\n// ------------------------------------------------------------\n// Debug helpers\n// ------------------------------------------------------------\nfunction buildDebugObj({ rows, inWindow, filtered, startISO, endISO, anchorISO }) {\n  const availService = topValues(inWindow, \"service\");\n  const availRegion = topValues(inWindow, \"region\");\n  const availPop = topValues(inWindow, \"pop\");\n\n  const sample = (filtered[0] ?? inWindow[0] ?? null);\n  const sampleCompact = sample ? {\n    ts: sample.ts,\n    service: sample.service,\n    region: sample.region,\n    pop: sample.pop,\n    edge_status: sample.edge_status,\n    ttms_ms: sample.ttms_ms,\n    url: sample.url,\n  } : null;\n\n  return {\n    rows_total: rows.length,\n    rows_inWindow: inWindow.length,\n    rows_filtered: filtered.length,\n    time: { anchor: anchorISO, start: startISO, end: endISO },\n    available: {\n      service: availService,\n      region: availRegion,\n      pop: availPop,\n    },\n    sample: sampleCompact,\n  };\n}\n\nfunction debugBlock(dbg) {\n  // Compact Slack-friendly debug block\n  const aS = dbg.available.service?.join(\", \") || \"n/a\";\n  const aR = dbg.available.region?.join(\", \") || \"n/a\";\n  const aP = dbg.available.pop?.join(\", \") || \"n/a\";\n  const sample = dbg.sample ? JSON.stringify(dbg.sample) : \"n/a\";\n\n  return [\n    `--- DEBUG ---`,\n    `rows_total=${dbg.rows_total}`,\n    `rows_inWindow=${dbg.rows_inWindow}`,\n    `rows_filtered=${dbg.rows_filtered}`,\n    `anchor=${dbg.time.anchor}`,\n    `start=${dbg.time.start}`,\n    `end=${dbg.time.end}`,\n    `avail_service=${aS}`,\n    `avail_region=${aR}`,\n    `avail_pop=${aP}`,\n    `sample=${sample}`,\n  ].join(\"\\n\");\n}\n\n// ------------------------------------------------------------\n// Inputs from Parser\n// ------------------------------------------------------------\nconst parsed = $items(\"Parser\")[0].json;\n\nconst service = parsed.service ?? \"all\";\nconst region = parsed.region ?? \"all\";\nconst pop = parsed.pop ?? \"all\";\nconst windowMinutes = Number(parsed.windowMinutes ?? 60);\nconst filters = Array.isArray(parsed.filters) ? parsed.filters : [];\nconst debug = !!parsed.debug;\n\n// ------------------------------------------------------------\n// CSV text (HTTP node output)\n// ------------------------------------------------------------\nconst csvText = $json.csvText ?? $json.body;\nif (!csvText) {\n  throw new Error(\n    \"No CSV text found. Set HTTP Response Format=Text and Put Output in Field=csvText (or use body).\"\n  );\n}\n\nconst rows = parseCsv(csvText);\n\n// ------------------------------------------------------------\n// Anchor on MAX timestamp and compute window\n// ------------------------------------------------------------\nlet anchor = null;\nfor (const r of rows) {\n  const ms = toMs(r.ts);\n  if (!Number.isNaN(ms)) anchor = anchor == null ? ms : Math.max(anchor, ms);\n}\n\nlet start = null;\nlet end = null;\nif (anchor != null) {\n  end = anchor;\n  start = anchor - windowMinutes * 60 * 1000;\n}\n\nconst inWindow = rows.filter(r => {\n  if (anchor == null) return false;\n  const ms = toMs(r.ts);\n  if (Number.isNaN(ms)) return false;\n  return ms >= start && ms <= end;\n});\n\nconst startISO = start != null ? new Date(start).toISOString() : \"n/a\";\nconst endISO = end != null ? new Date(end).toISOString() : \"n/a\";\nconst anchorISO = endISO;\n\n// ------------------------------------------------------------\n// Apply filters\n// ------------------------------------------------------------\nlet filtered = inWindow\n  .filter(r => matchDim(r.service, service))\n  .filter(r => matchDim(r.region, region))\n  .filter(r => matchDim(r.pop, pop));\n\nfor (const f of filters) {\n  filtered = filtered.filter(r => passesFilter(r, f));\n}\n\n// Build debug object once (works for all code paths)\nconst dbg = debug ? buildDebugObj({ rows, inWindow, filtered, startISO, endISO, anchorISO }) : null;\n\n// ------------------------------------------------------------\n// UX: Empty window / No matches\n// ------------------------------------------------------------\nif (inWindow.length === 0) {\n  const summary = [\n    `CDN TRIAGE SUMMARY`,\n    `No data found in the requested time window.`,\n    `Service: ${service}  Region: ${region}  POP: ${pop}`,\n    `Window: ${windowMinutes} minutes`,\n    `Time Range (UTC): ${startISO} → ${endISO}`,\n    `Filters: ${prettyFilters(filters)}`,\n    ...(debug && dbg ? [\"\", debugBlock(dbg)] : []),\n  ].join(\"\\n\");\n\n  return [{\n    json: {\n      ...$json,\n      timeRangeUTC: { start: startISO, end: endISO },\n      totalRequests: 0,\n      errorRate5xxPct: null,\n      p95TtmsMs: null,\n      summaryText: summary,\n      debug: dbg,\n    }\n  }];\n}\n\nif (filtered.length === 0) {\n  const availService = topValues(inWindow, \"service\");\n  const availRegion = topValues(inWindow, \"region\");\n  const availPop = topValues(inWindow, \"pop\");\n\n  const summary = [\n    `CDN TRIAGE SUMMARY`,\n    `No rows matched your filters.`,\n    `Requested:`,\n    `- service=${service}`,\n    `- region=${region}`,\n    `- pop=${pop}`,\n    `- window=${windowMinutes}m`,\n    `- filters=${prettyFilters(filters)}`,\n    `Available values in this window:`,\n    `- service: ${availService.length ? availService.join(\", \") : \"n/a\"}`,\n    `- region: ${availRegion.length ? availRegion.join(\", \") : \"n/a\"}`,\n    `- pop: ${availPop.length ? availPop.join(\", \") : \"n/a\"}`,\n    `Try: /triage service=${(availService[0] ?? \"all\").split(\" \")[0]} window=${windowMinutes}m`,\n    ...(debug && dbg ? [\"\", debugBlock(dbg)] : []),\n  ].join(\"\\n\");\n\n  return [{\n    json: {\n      ...$json,\n      timeRangeUTC: { start: startISO, end: endISO },\n      totalRequests: 0,\n      errorRate5xxPct: null,\n      p95TtmsMs: null,\n      summaryText: summary,\n      debug: dbg,\n    }\n  }];\n}\n\n// ------------------------------------------------------------\n// Metrics\n// ------------------------------------------------------------\nconst total = filtered.length;\n\nconst errorCount = filtered.filter(r => Number(r.edge_status) >= 500).length;\nconst errorRate = total ? (errorCount / total) * 100 : null;\n\nconst ttmsVals = filtered\n  .map(r => Number(r.ttms_ms))\n  .filter(v => Number.isFinite(v));\n\nconst p95 = percentile(ttmsVals, 95);\n\n// ------------------------------------------------------------\n// Summary (Slack-ready)\n// ------------------------------------------------------------\nconst summary = [\n  `CDN TRIAGE SUMMARY`,\n  `Service: ${service}  Region: ${region}  POP: ${pop}`,\n  `Window: ${windowMinutes} minutes`,\n  `Time Range (UTC): ${startISO} → ${endISO}`,\n  `Filters: ${prettyFilters(filters)}`,\n  `Total Requests: ${total}`,\n  `5xx Error Rate: ${errorRate == null ? \"n/a\" : errorRate.toFixed(2) + \"%\"}`,\n  `P95 TTMS: ${p95 == null ? \"n/a\" : Math.round(p95) + \" ms\"}`,\n  ...(debug && dbg ? [\"\", debugBlock(dbg)] : []),\n].join(\"\\n\");\n\nreturn [{\n  json: {\n    ...$json,\n    timeRangeUTC: { start: startISO, end: endISO },\n    totalRequests: total,\n    errorRate5xxPct: errorRate,\n    p95TtmsMs: p95,\n    summaryText: summary,\n    debug: dbg,\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        672,
        112
      ],
      "id": "21238229-df45-42f2-a543-c3717e79858c",
      "name": "Metrics"
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Parser",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "Metrics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parser": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          },
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Metrics": {
      "main": [
        [
          {
            "node": "Send a message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false
  },
  "versionId": "5a767c5f-e34e-4b2e-a1ac-ab494bfe3d4e",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "6764c79f47394251996df2c5f4c1e6280e5cf80debb2f3d7d17e476093ee3f99"
  },
  "id": "RUD3N79Ta4y850BEbPVEU",
  "tags": []
}